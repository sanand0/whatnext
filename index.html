<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Priority Matrix</title>
  <style>
  /* Based on normalize.css */
  html {
    font-family: Helvetica, Arial, sans-serif;
    -webkit-text-size-adjust: 100%;
        -ms-text-size-adjust: 100%;
  }
  body {
    margin: 0 auto;
    padding: 20px 0;
    width: 920px;
  }
  *, *:before, *:after {
    -webkit-box-sizing: border-box;
       -moz-box-sizing: border-box;
            box-sizing: border-box;
  }

  h1 {
    font-family: Helvetica, Arial, sans-serif;
    margin: .67em 0;
    font-size: 2em;
  }

  /* This is the DOM structure we're using:
        #container        Overall container
          - svg.gridbase  Background grid
          - div#items     Container for items
              - div.item  Individual iteemes
   */
  #container { position: relative; }
  #items { overflow: hidden; }

  .item {
    position: absolute;
    max-width: 15em;
    min-width: 5em;
    padding: 0.15em 0.25em;
    background-color: #fff;
    border: 1px solid #5b9bd5;
    opacity: 0.95;
    border-radius: 5px;
  }
  /* http://stackoverflow.com/a/12968143/100904 */
  .item:before {
    width: 50%;
    position: absolute;
    top: -5px;
    left: -1px;
    content: '';
    border-top: 5px solid #5b9bd5;
    cursor: move;
  }
  .item:focus, .item:hover {
    z-index: 1;
  }
  .item:hover:before, .item:focus:before {
    top: -20px;
    border-top-width: 20px;
  }
  .item:focus:before {
    border-top-color: #ed7d31;
  }
  .to-be-deleted {
    opacity: 0.5;
  }
  .to-be-deleted:before {

  }

  /* Button styling */
  .button {
    display: inline-block;
    vertical-align: middle;
    font-size: 14px;
    line-height: 20px;
    height: 34px;
    font-weight: normal;
    border: 1px solid #ccc;
    background-color: #fff;
    color: #333;
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    white-space: nowrap;
  }
  .button:hover, .button:focus, .button:active {
    background-color: #ebebeb;
    border-color: #adadad;
  }

  /* Grid styling */
  #gridbase rect {
    fill: #eee;
  }
  #grid path {
    stroke: #ccc;
    fill: none;
  }
  .legend {
    cursor: pointer;
  }
  .legend:hover {
    fill: #ed7d31;
  }

  /* Body text (help, mainly) uses this style. Typography inspired by atlas.oreilly.com */
  .copy {
    max-width: 690px;
    color: #333;
    font-size: 18px;
    line-height: 1.3em;
    font-family: "Book Antiqua", Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, serif;
    -webkit-font-smoothing: subpixel-antialiased;
    letter-spacing: .01em;
  }
  </style>
</head><body>

<h1>
  Priority Matrix
  <button id="add-item" class='button'>New item</button>
</h1>

<div id="container">
  <svg id="gridbase" width="920" height="559" ondragover="return false"><!-- 920 / 559 ~ Golden ratio -->
    <rect width="100%" height="100%"/>
    <g id="grid">
      <path d="M0,0h100v100"/>
    </g>
    <text id="col:new" class="add-label legend" x="920" y="559" dx="-1em" dy="-8">+</text>
    <text id="row:new" class="add-label legend" x="0" y="0" dx="8" dy="1em">+</text>
  </svg>
  <div id="items">
    <div draggable="true" class="item" style="left:270px;top:110px" contentEditable>Items can now be deleted. Just delete the text</div>
    <div draggable="true" class="item" style="left:360px;top:170px" contentEditable>Empty items will automatically vanish after 5 seconds</div>
    <div draggable="true" class="item" style="left:100px;top:390px" contentEditable>But in those 5 seconds, you can go back and undo the change</div>
    <div draggable="true" class="item" style="left:600px;top:390px" contentEditable>Drag this item's handle to move it to a different location</div>
    <div draggable="true" class="item" style="left:45px;top:180px" contentEditable>The state of the page is automatically saved in the browser, and restored when you load the page back</div>
  </div>
</div>

<div id="help" class="copy">
  <p>Sometimes, it’s hard to figure out what to do next.</p>
  <p>One classic approach is to list all your items, rate them on an urgency and importance scale, and pick those on the top right quadrant.
     Stephen Covey explains this in his book <a href="http://en.wikipedia.org/wiki/First_Things_First_(book)" target="_blank">First Things First</a>.</p>
  <p>This can be generalised. Almost anything can be prioritised on a grid.</p>
  <p>This page is an <strong>offline single-page app</strong> that lets you add things and move them around. You can pick your axis scales.
     Everything’s saved in your browser and available the next time you visit. (But it won’t be available in other browsers or for other people.)</p>

  <h1>Usage</h1>
  <ul>
    <li><strong>Add an item</strong> by clicking on the “New item” button on top. You can edit and move the item around.</li>
    <li><strong>Delete the item</strong> by delete the text in it. It will vanish in 5 seconds after it loses focus. (If you change your mind, click on the item and press <kbd>Ctrl-Z</kbd> to undo.)</li>
    <li><strong>Edit labels</strong> by clicking on the labels at the left and bottom. To delete a label, edit it and make it blank. It will automatically be removed.</li>
    <li><strong>Add labels</strong> by clicking on the “+” button at the top left or bottom right.</li>
    <li>Your actions are automatically saved in your browser. Re-visit the page to continue from where you left off.</li>
  </ul>
</div>

<script>
// A crude version of event delegation
// All live events are bound to the container.
// on('click', 'item', handler) runs handler if a ".item" is clicked.
var container = document.getElementById('container')
function on(event, className, handler) {
  container.addEventListener(event, function(e) {
    // SVG .className is an object with .baseVal and .animVal. HTML .className is a string
    var cls = (typeof e.target.className == 'object' ? e.target.className.baseVal : e.target.className).split(/\s+/)
    for (var i=0, l=cls.length; i<l; i++)
      if (cls[i] == className)
        return handler(e)
  }, false)
}

// Construct an SVG element. e.g. svg('path', {d: 'M10,10h100', stroke: '#000'})
function svg(tag, attrs, text) {
  var element = document.createElementNS('http://www.w3.org/2000/svg', tag)
  for (var key in attrs)
    element.setAttributeNS(null, key, attrs[key])
  if (typeof text !== 'undefined')
    element.appendChild(document.createTextNode(text))
  return element
}

// Replace multiple whitespaces with a single space, and remove leading + trailing space
function strip(s) {
  return s.replace(/\s+/g, ' ').replace(/^ /, '').replace(/ $/, '')
}


// Make items draggable
var startX, startY
on('dragstart', 'item', function(e) {
  startX = e.screenX
  startY = e.screenY
  // Firefox won't trigger dragend without dataTransfer.setData().
  // IE does not like 'text/plain' -- only 'text'. http://stackoverflow.com/a/26660055/100904
  e.dataTransfer.setData('text', '')
})
on('dragend', 'item', function(e) {
  // Firefox dragend sets clientX to 0. Using screenX instead
  e.target.style.left = parseInt(e.target.style.left) + e.screenX - startX + 'px'
  e.target.style.top = parseInt(e.target.style.top) + e.screenY - startY + 'px'
  save()
})


// #add-item button adds a random item on the page
var items = document.getElementById('items')

function add_item(item_state) {
  var item = document.createElement('div')
  item.appendChild(document.createTextNode(item_state.t))
  item.setAttribute('draggable', 'true')
  item.setAttribute('class', 'item')
  item.setAttribute('contentEditable', 'true')
  item.style.left = item_state.x + 'px'
  item.style.top = item_state.y + 'px'
  items.appendChild(item)
  return item
}

document.getElementById('add-item').addEventListener('click', function(e) {
  // Add the item just below the new item button, making it easier to drag it
  add_item({
    x: this.getBoundingClientRect().left - document.body.getBoundingClientRect().left,
    y: -10,
    t: 'New item'
  }).focus()
  save()
})

// If an item is left empty, schedule its deletion in a few seconds
on('focusout', 'item', function(e) {
  if (!e.target.textContent) {
    if (e.target.timeout)
      clearTimeout(e.target.timeout)
    e.target.timeout = setTimeout(function() {
      // Delete after a few seconds but only if it's still empty, and to be deleted
      if (!e.target.textContent && e.target.classList.contains('to-be-deleted')) {
        e.target.parentNode.removeChild(e.target)
        save()
      }
      else
        e.target.classList.remove('to-be-deleted')
      delete e.target.timeout
    }, 5000)
    e.target.classList.add('to-be-deleted')
  } else
    save()
})

on('focusin', 'item', function(e) {
  e.target.classList.remove('to-be-deleted')
})

// draw_grid() draws a background grid and label the grid
var gridbase = document.getElementById('gridbase'),
    grid = document.getElementById('grid'),
    box = gridbase.getBBox(),
    pad = 8
function draw_grid() {
  // Clear the grid
  for (var nodes=grid.childNodes, i=nodes.length - 1; i >= 0; i--)
    grid.removeChild(nodes[i])
  // Draw the grid
  for (var i=0, n=labels.col.length, w=box.width / n; i<n; i++) {
    grid.appendChild(svg('path', {d: 'M' + i * w + ',0 v' + box.height}))
    grid.appendChild(svg('text', {id: 'col:' + i, 'class': 'label legend', x: (i + .5) * w, y: box.height - pad, 'text-anchor': 'middle'}, labels.col[i]))
  }
  for (var i=0, n=labels.row.length, h=box.height / n; i<n; i++) {
    y = (n - .5 - i) * h
    grid.appendChild(svg('path', {d: 'M0,' + (y + h * .5) + ' h' + box.width}))
    grid.appendChild(svg('text', {id: 'row:' + i, 'class': 'label legend', x: 0, y: y + pad, dy: '0.35em', 'text-anchor': 'middle', transform: 'rotate(-90,5,' + y + ')'}, labels.row[i]))
  }
  save()
}

// The data for the labels is here
var labels = {
  row: ['Urgent', 'Slightly urgent', 'Not urgent'],
  col: ['Not important', 'Slightly important', 'Important']
}

// Clicking on any label lets you edit or delete it it
on('click', 'label', function(e) {
  var key = e.target.getAttributeNS(null, 'id').split(':'),
      axis = key[0],
      index = +key[1],
      current_label = labels[axis][index],
      new_label = prompt('Rename "' + current_label + '". (Or make it blank to delete)', current_label)
  if (new_label !== null) {
    new_label = strip(new_label)
    if (new_label)
      labels[axis][index] = new_label
    else
      labels[axis].splice(index, 1)
    draw_grid()
  }
})

// Clicking on the '+' icons lets you add a new row or column
on('click', 'add-label', function(e) {
  var key = e.target.getAttributeNS(null, 'id').split(':'),
      axis = key[0],
      new_label = prompt('Add ' + axis, 'Name')
  if (new_label !== null) {
    new_label = strip(new_label)
    if (new_label) {
      labels[axis].push(new_label)
      draw_grid()
    }
  }
})

// The state of the application is computed by a simple JSON object
function save() {
  var items = []
  for (var i=0, nodes=document.querySelectorAll('.item'), node; node=nodes[i]; i++)
    items.push({
      x: parseInt(node.style.left),
      y: parseInt(node.style.top),
      t: node.textContent
    })
  var state = {
    item: items,
    row: labels.row,
    col: labels.col
  }
  localStorage['priority'] = JSON.stringify(state)
}

// Load the state from localStorage
function load(state) {
  labels.row = state.row
  labels.col = state.col
  for (var nodes=document.querySelectorAll('.item'), i=nodes.length - 1; i >= 0; i--)
    items.removeChild(nodes[i])
  for (var i=0, item_state; item_state=state.item[i]; i++) {
    add_item(item_state)
  }
}

if ('priority' in localStorage)
  load(JSON.parse(localStorage['priority']))

// Initialise with the default grid
draw_grid()
</script>
</body></html>
